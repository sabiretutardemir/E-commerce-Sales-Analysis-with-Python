# -*- coding: utf-8 -*-
"""Ecommerce Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZZkFECmqO5-f8EyAsIwoToC0UASuFIhx

# **Olist E-Commerce Order Analysis**

This notebook is written for **Brazilian E-Commerce Public Dataset by Olist.**

[Click to reach the dataset](https://www.kaggle.com/datasets/olistbr/brazilian-ecommerce?select=olist_order_reviews_dataset.csv)

Data Set Link: https://www.kaggle.com/datasets/olistbr/brazilian-ecommerce?select=olist_order_reviews_dataset.csv

**❇ Table of Contents:**

1.   Goal of this Notebook
2.   Introduction of Dataset Schema
3.   Importing the Libraries
4.   Loading the Tables
5.   Basic EDA Analysis and Preprocessing Data
  *   5.1. Exploring of df_customers
      * 5.1.1. Mini Analysis; One Time Buyers vs Repeating Customers
  *   5.2. Exploring of df_geolocation
      * 5.2.1. Combine df_customer and df_geolocation
      * 5.2.2. Mini Analysis; Customer Count, Order Count and Average Order Count based on Regions
  *   5.3. Exploring of df_products
      * 5.3.1. Mini Analysis: Measuring Category Variety
  *   5.4. Exploring of df_sellers
      * 5.4.1. Pulling Latitude and Longitude Informations from df_geolocations
      * 5.4.2. Mini Analysis: Seller Locations vs Customers Locations
  *   5.5. Exploring of Orders DataFrames
      * 5.5.1. Exploring of df_orders
      * 5.5.2. Exploring of df_order_item_details
      * 5.5.3. Combining df_orders and df_order_items
6.   Business Questions
  *   Question 1: Sales Trend Analysis
  *   Question 2: Delivery Performance Analysis
  *   Question 3: Product Performance Analysis based on States
  *   Question 4: Cross Selling and Up Selling Product Combinations
  *   Question 5: Impact of Shipment Costs
7.   Final Discussion

# **1.Goal of this Notebook**

The goal of this notebook is to analyze Olist Market's e-commerce orders meticulously in order to be able to make data-driven strategic decisions to increase sales volume and profitability.



> As a data scientist, my role is to help the business make data-driven decisions to optimize sales and shipment processes, improve customer experience, and increase revenue and profitability for Olist Market. Olist Market has a large dataset shows customer transictions, order details, product informations, sales trend, seller and customer locations.


> I analyzed this data to create actionalbe insights and shared my findings to enhance product sales, improve shipment process and decrease costs, define new oppotunities to enhance customer exprience. Basically 5 business problems were addressed and answered with deep dive analysis and visuals.

# **2.Introduction of Dataset Schema**

**Dataset Summary**

The dataset is from Olist Store and includes e-commerce sales orders along with details such as order value, quantity, customer, seller, geographical details from 2016 December to 2018 August. Each table explained along with their columns as follows;




```
Figure 1: Data Schema of Brazillian Olist Market Dataset
```
![Table Context of (2).png](data:image/png;base64,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5gMVjzhEHOvzPgwREZEHyv68D0BERETk0woAJ+LQ1tRARVmU8ngM3w+ora6kq6MFz/PxPPUVFhG5F9M0qa+ppqG2mvnFFQgC4rEoXW3NWJaN53lqwSMiIrIPKBQWERGRLxU/CPA9Dy+I4gcBhgGeF1AsKsgQEfk0PM8lCMArLc7pBTtj6Od8YCIiIvLAqKewiIiIfKnsNIa4tUOEYez9XkREPklp0DR2vyuNoxpIRURE9guFwiIiIiIiIiIiIiL7iEJhERERERERERERkX1EobCIiIiIiIiIiIjIPqJQWERERERERERERGQfUSgsIiIiIiIiIiIiso8oFBYRERERERERERHZRxQKi4iIiIiIiIiIiOwjCoVFRERERERERERE9hGFwiIiIiIiIiIiIiL7iEJhERERERERERERkX1EobCIiIiIiIiIiIjIPqJQWERERERERERERGQfUSgsIiIiIiIiIiIiso8oFBYRERERERERERHZRxQKi4iIiIiIiIiIiOwjCoVFRERERERERERE9hGFwiIiIiIiIiIiIiL7iEJhERERERERERERkX1EobCIiIiIiIiIiIjIPqJQWERERERERERERGQfUSgsIiIiIiIiIiIiso8oFBYRERERERERERHZRxQKi4iIyJeQUfqvsfu1iIh8euHoWRpLDY2lIiIi+83/BwAA///s3dlzZGd5x/Hve7bu1tqtbrWk0cxo9vGMZ+wZr5h4AQbHEBtis9gEF1CEIlyQSqVS+QP8D+QqFykqqUoBCQWBmIBZgs3i2C4bGxvb2Hj2RaNttLZ6HbW6z3lz0S1ZHsZOBkaSRf8+VapptbrPOaOLR9LvPO/zKhQWERGRDcgCEEURURRhrV3n6xER2VisBRtZwBJFFovqqIiISCvx1vsCRERERK6U4zjUahFbN/dTqlwkm+lBubCIyP+f40C2t4f+bC/bNg/gua5usImIiLQQY/WTX0REZM0UK1Ui/ei9KgxQC0Pq9ZDA93CcP3wBlLW2uYz6nZ8TEVlt1sJql54oiqhWF/F9H993V+Xm2lv+3DTmXTmkIhH4BL673pchIiKyptQpLCIiIhuSBTzXxfe8q9bd5roOUfTWYznGaFG1iKwpYwzGsKqdu8YYHMehrS0BrN65XMdp1FBrsY3/1KqcR0RERK6MQmERERFZNStDBmPMW7puL3288nX1eh0weJ77tse53DmWvv5/vefSzl/Hcbh4cYHh0VG2bdlCEPhYawmjiAsXJslk0iTicS2tFpFVsVRbrLW4rsvsXI5ypcLWzYNEUbT8undatXC5Gvd2dbBSuUi+UKA3k8H3V9xYe4dO3is5/tLn9TBkbPwCBks8HieMIgYH+qmHYeOG2xp0Q4uIiMjlaaM5ERERWTWu6xKLBQRBgDEG13WXxzx4novjNNIA3/eJx2L4vo/rujz/0iu8fvQ4nudhLQSBTywWLIfErus2n4s1lz03Hrvum8t/l77ueY174J7rEjTPs/J1jXAaqouLnDpzjsXaIq7jEo/52Cjkv3/2JLncPI7jqMFNRFbFUm2KxQIC3yM3P8/o2AQAnucRiwXEYsE7jsnxfY94PEbg+xgaqxxiQUAs5i+/z3VdYoHP2Pg4P/2fZygUixhjlo/vvs3xjTHLNTUI/GYns8H3PWJBsPyc73vLddcYw/T0LE8+/SwXJqeZnpljcmoaz3XxmjXYc52rMvpHRERErpw6hUVERGTV5ObzjE1cIB4L2LZlC5XqAmG9TmdHBzOzOdrbErS1JTh7foRcLk8q2UWmJ8VLL/8G3/PYu3sH8ViM02eHKZXKDPT3kezuIpebp1QuUyiW6EmlsFhyuTwD/VmS3V2A5ezwefL5IgP9faR7UkzPzlEuVyiWivRls2TSqWaXmiGKLPFYjIP7ryEWi1EslxkdHace1pmanmWxVmt2z1l4V07EFJGNylrLmeFhCsUSgR/Qm+khk07T0d6GtZbJ6WlyuTxhGDI40E9HR/tlZ5+PjV9gYnKKvt4M/X1ZLlYqjIxP4LkuWwY3EYvFmJ/PMzI+wcjYONMzc0RRRK1W49iJU0RRxNDWzbS3tf3OqoiFapXp0VlK5TJBELBlcADHOExO5SgUS3ieR39fL3Nz88zOzdHXlyWbSXP63DnmC3nS6RSpZBIw5AtFypUKPakkc7l5PN+jq6NjDb/jIiIiAgqFRUREZJXMzc3z/R8/weTUNLFYwF984n7ODp9nanqaP/3AXTz6/R9y+223EgQ+X/vmd9jU30+yu5MbD19HoVigVL5IuVzh6PGTfP9HjxOPxUine3jgvg/xxC+e4tXfHmVo8yDDI2P0pnu4uLBALAj42y9/kZdffZ3HfvQ4yWQ37W1tPHj/h/nOYz/h3MgoQ4OD3Hzj9WTSPYDFWkvg+0xMTvHPX/0GX/zcp3n2+Rd549gJEok4Y+MTjbnFCoRFZBWEUcRrvz3BiZOnOT86yoc++H6CwOfYydP89Rce5t+/9ShTMzMk4nG2bt7Mw598AOOY5Q5bxzEcO3Ga7/7wcQLfIx6P8+D99/Hk089x4tRpqouL3HzDIe695whf+dd/o1K5SL1ex/N96mHIt7/3A06ePEtHZzupZDefvP8+Ojs6loNhx3EYHhnln/7l6/RnMxRLZT7y4bvZu3sn//CPX6G/L8ueXTs5PzLG8y+9jOe5FEtlPvPQx5mdyzE8PMb4xBRHj5+iVq9x5M7b+do3vs31B69l4sIUt9x0iK5dHdrUU0REZI1prY6IiIhcVUv9ZZPT0xgDn//MQ3zhs5+iN9PDwkKVWq2OtZaFhSrWRuRy8+QLRW698RDvveUmtgxuYqCvn0MH9zO0qY9nnnuBQwf386XPP0wsCLgwOU2tFnL44LV86bMPMZDtZd/e3fzlZx5iNpdjamqWJ37xFAMDfTxw7z0AjE/OsLhY49C1+/nyX32O6w9e+9ZOOANRFFEuV5jLzTM2PsHHP/pnfPoTD5Ds7iayCoRFZHW4jsPd77+dm2+4np3bt3H4uv3Uw5CFhcXm+JyAe+/+AJ/62EcplkoUSqXmOJtGiBqGEafPnmfX9iH+7stf5ME/v5d6PSQ3P89DD9zHffcc4diJU5w+O8x8ocDf/82XuOfIXXR3dTA5PcNzv3yJu4/cyd3vv5O5XJ7xC5ON+cDN6zNAFEb09/Xy+Ycf5H2338bpc+eAxkiJBz/2Ee45cidnzg2T7knxyfs/QlsiwYlTp9mzYwe33nSYmw4fpB6GVCoLDGR7uHbfXr7+rf8k0RZn+7YtjfMoEBYREVlTCoVFRETk6lraMInGrGDf80jEY/ieC8YQRhFR82OxVmPf3j188K7befX1N/iP/3qM4ydO0ejgbRwuDKPlGZW+7xFGIYHvk+5J4bguPekUya5O2hMJ2hIJFus1AEbHJnjjxGky6R4y6RSB75FKduM4bnODI/uWzZ0AHMfFWovjuvi+R1siTiwItMGciKyKpY3lzo+Oc/LMWe664zY2Dw7gGIPjNmeuex5BEOD7Pp7rEYZh872N90eRBWtJxOM4jqGjPYEx4LoOnt+YR2wwVKuLjRnDgU8QeDiuC9ayUK1y9PhJzpw7z+6d2+ju6mpsbteskRbAGOJBrDkzOGhefER3Vxdt8TjGNDqex8Yn+PUrvyGbSTO0dQuhjRo7yZnGjGPHMVgMHe1tdLS3EY/FVozmERERkbWk8REiIiJyVS11eyW7uyiXy/z0F09jbcQd772VTDrJ8y++xE9+/hTDo2NgYWRsjHy+SLY3w8j4OOVKha6uDk6cOsvkzBz79+3htdePUiqVKRSK9CSTWJYC3aXQYincbWzYdPi6Azz93AuEYYjveyRiwXLn21J33crNjVzHYDDNQKWdjrZ2nnr2BWJBwPTsLL6nX5lE5OozxrBQrfLYj5+gUrnIxMQkZ5uzd00zLp3PF3j6uV/Rk0qCgc7Oxkxhz2tuHue4ZLMZnnr2ebzHXeZyOd53x3vxPZ8nn/klpXKFbDbD9qEthPWIbz76A+ZyOUrlCulUiv3X7KZQaNRgMLS3JXBdd/lmmOs4YOHcyAg/+flTjE1Mcv2BfURRhDEOkbUEQcCu7UNMz8w2NqEDOtrbyBeKmOaGopjGpnkTF6Z48ZXXuOfI+5iZm+Ps8Ai7d25f+2++iIhIi3MfeeSRR9b7IkRERFrFYi1smX6otkSCRCLB1PQM7e3t7N29i55kklq9TrW6yM7tQ+zbu5vOzg6mZ+eoVMoc2HcNh667lv5shjCyZDI97Nm1g4sLVRaqVQ5dd4DtQ1vxm5saJZNJHMelvy9Ld1cnQSxgy+Amdu/YhmMMxWKJzYMDDG3ZjO8HbBroJ5XsplQqMzk9zfx8gfl8nmKpsXlSV2c7e/fspK83Q26+sfHdwWuvYdvWLQRBsN7fUhH5I2OMYbFapVAs0dHRjrWQSnbT05MilUqyeaCPl197A4OhJ53ilhsPEQ8CJqemKRSL5PMFypUK2Uwaz3UZvzDJ4GA/e3fvorurm9ncPN1dndxx2y1kMmm6uzqZnp0j25th355d7N65ne3btjKfz1Or1dm5fYj2tgQzM7PM5wvkCwWKpTLlSoVTp8+RSnYz2N/PLTceIpGIk4jH2Dy4CX9p9YZxmJ3LMTjQz+6dO4j5Hp0dHfSm03ieS182i+M4pFLdvOfmG4kFAZ7nke5JretMYd91cV0tohURkdZirNZDioiIrJlipdqcT9s6oijEMQaMA9jmeAkLxgUanzrGEoV1jOOBaTzXyAZMc4yEBdvoSmNFaLD0td8NEpqdxDbCOC40e+4iazGOw8joOK8fPU5YrwPgBz43H76eTDpFFEVYDERho+PNOC0T5IvI2muWOoyNALA4WAM2jHBc+Oo3HuXAvj0cPrgfL4jxxrETHD1xqrEBprV0tLdx3YH9pFNJorCGcT0atdMCEbCijjWfMzjLqyciazHN2mwxnDxzjtNnzzXGUmCJx2L0JJO8+MqrfOKjHyaVTIJxljuCV9ZHay02CnE8F2sbX7/0Nca8OfrCaXYRr/ePxUTgE/ju+l6EiIjIGlMoLCIisoZaLRReObd3aVxD4zmazzUCgShqBBcrA96lrjFjzHI4sfT5ymM6jkMYhsujIZzm+6NG6vA772k8hktnWDbOEzU2cFo6/9IxHXWQicjqadTAhpU3uYwx5PMFgiAgHo8t17JLt75cfv6SmvfmjTOnGca++RpLY86v57rUwhAbRW/bqbtYq1EuV+jq7MB13eXXRStq7pv1vlHLl2rpUh1+889OsxwIr6zL60mhsIiItCKFwiIiImuo1ULh1WJpzLmcmcsxl8uzqb+X9ra2K9oQ7tIQQr8Sici7zdJGdCtvsF0uQP1961epXOH82AWymR5606l3PMfSDbg/RgqFRUSkFantRURERDacKIqIx3x+/ZtjfO/xpzhzfpwrbTRbCllWhi0iIu8mSysYVtaoS2vXH1K/Tp0b4Uc/e4YXXv0tYRgudx9f7hx/rIGwiIhIq1IoLCIiIhuPbYyeKC8sUKlcZGGhut5XJCKyoVhgobrIYr1OuXKxsYplncc4iIiIyNpRKCwiIiIblqGRYSjHEBH5PRgwja01URkVERFpLQqFRUREZAPSuAcRkatB03NERERak0JhERERERERERERkRaiUFhERERERERERESkhSgUFhEREREREREREWkhCoVFREREREREREREWohCYREREREREREREZEWolBYREREREREREREpIUoFBYRERERERERERFpIQqFRURERERERERERFqIQmERERERERERERGRFqJQWERERERERERERKSFKBQWERERERERERERaSEKhUVERERERERERERaiEJhERERERERERERkRaiUFhERERERERERESkhSgUFhEREREREREREWkhCoVFREREREREREREWohCYREREREREREREZEWolBYREREREREREREpIUoFBYRERERERERERFpIQqFRURERERERERERFqI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ERERERERERFZQRQKi4iIiIiIiIiIiKwgCoVFREREREREREREVhCFwiIiIiIiIiIiIiIriEJhERERERERERERkRVEobCIiIiIiIiIiIjICqJQWERERERERERERGQFUSgsIiIiIiIiIiIisoIoFBYRERERERERERFZQRQKi4iIiIiIiIiIiKwgCoVFREREREREREREVpD/BwAA///t2IEAAAAAgCB/60EujKQwAAAAAMCIFAYAAAAAGJHCAAAAAAAjUhgAAAAAYEQKAwAAAACMSGEAAAAAgBEpDAAAAAAwIoUBAAAAAEakMAAAAADAiBQGAAAAABiRwgAAAAAAI1IYAAAAAGBECgMAAAAAjEhhAAAAAIARKQwAAAAAMCKFAQAAAABGpDAAAAAAwIgUBgAAAAAYkcIAAAAAACNSGAAAAABgRAoDAAAAAIxIYQAAAACAESkMAAAAADAihQEAAAAARqQwAAAAAMCIFAYAAAAAGJHCAAAAAAAjUhgAAAAAYEQKAwAAAACMSGEAAAAAgBEpDAAAAAAwIoUBAAAAAEakMAAAAADAiBQGAAAAABiRwgAAAAAAI1IYAAAAAGBECgMAAAAAjEhhAAAAAIARKQwAAAAAMCKFAQAAAABGpDAAAAAAwIgUBgAAAAAYkcIAAAAAACNSGAAAAABgRAoDAAAAAIxIYQAAAACAESkMAAAAADAihQEAAAAARgLXGc5hCqbvQQAAAABJRU5ErkJggg==)

**Table 1: "olist_customer_dataset"**
This table contains customer_id informations along with their zip codes and city, state informations which shows location of customers

**Table 2: "olist_geolocation_dataset"** This table involves latitude, longitude, city and state information based on zip codes


**Table 3: "olist_order_items_dataset"** This table covers the each products purchased within the same order along with seller, price and shipment costs details.

**Table 4: "olist_order_dataset"** This table shows customer and date and time (delivered date, shipment date, order purchase date) information for each order.

**Table 5: "olist_products_dataset"** This table covers product information such as category name, weight, height,  length, width values.

**Table 6: "olist_sellers_dataset"** This table contains seller informations along with location informations

# **3.Importing the Libraries**
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import datetime as dt
import calendar
import warnings
warnings.filterwarnings('ignore')

"""# **4.Loading the Tables**"""

df_customers=pd.read_csv("/content/olist_customers_dataset.csv")
df_geolocation=pd.read_csv("/content/olist_geolocation_dataset.csv")
df_order_items=pd.read_csv("/content/olist_order_items_dataset.csv")
df_orders=pd.read_csv("/content/olist_orders_dataset.csv")
df_products=pd.read_csv("/content/olist_products_dataset.csv")
df_sellers=pd.read_csv("/content/olist_sellers_dataset.csv")

"""# **5. Basic EDA Analysis and Preprocessing Data**

Head, tail , shape, missing value dedection, duplicated rows check and descriptive analysis will be reviewed.

The dataset has 6 different tables and each table are reviewed different sections.

## **5.1.Exploring of df_customers**
"""

print('Head 5 Examples of Customer Data : \n')
df_customers.head(5)

print("Tail 5 Examples of Customer Data: \n")
df_customers.tail(5)

#The rows and columns number
print("The shape of the customer table: ", df_customers.shape)

#Check duplicates
print("Duplicated rows number for customer dataset is: ", df_customers.duplicated().sum())

#Check missing values
print("The missing values of customer dataset: \n ")
df_customers.isnull().sum()

"""

> df_customers has no missing or duplicated values. It is not required to clean data.

"""

#Check data type for each columns
print("The data type of each columns of Customer table is: \n")
df_customers.info()

"""

> No descriptive analysis was performed for df_customers, Since it is a dimensional table that contains only descriptive information and no metrics.Performing descriptive analysis wouldn't provide much value on its own.
"""

#Rename the column of customer_zip_code_prefix increase readability
df_customers.rename(columns={"customer_zip_code_prefix":"zip_code"},inplace=True)

"""### **5.1.1. Mini Analysis; One Time Buyers vs Repeating Customers**

> For each order, new "customer_id" was defined to track that order.
> This indicates that the same customer will get different customer_id for different orders.

> To identify same customers "customer_unique_id" columns will be used. By using "customer_unique_id" we can calculate the number of orders by placed for each customer.
"""

# Calculate the number of total customers
total_customers = df_customers['customer_unique_id'].nunique()
print(f"Total number of customers: {total_customers} \n")

# Calculate number of distinct orders for each customer and rename the column
numberoforders_by_customers = df_customers.groupby("customer_unique_id")["customer_id"].nunique().reset_index()
numberoforders_by_customers.rename(columns={"customer_id":"number_of_orders"},inplace=True)

# Filter for customers with more than one order
customers_with_multipleorders = numberoforders_by_customers[numberoforders_by_customers["number_of_orders"] > 1]

# Calculate the number of customers with more than one order
num_customers_with_multiple_orders = len(customers_with_multipleorders)

onetimebuyers = numberoforders_by_customers[numberoforders_by_customers["number_of_orders"] == 1].shape[0]

print(f"Number of customers with more than one order: {num_customers_with_multiple_orders} \n")
print(f"Total number of one time buyer customers: {onetimebuyers} \n")
print("Number of orders for each customer: \n")
print(numberoforders_by_customers.sort_values(by="number_of_orders",ascending=False))

#Visualize the one-time-buyers and repeat buyers

#Customer categorization such as "One Time Buyer" or "Repeat Buyer"
numberoforders_by_customers['customer_type'] = numberoforders_by_customers['number_of_orders'].apply(lambda x: 'One-time buyer' if x == 1 else 'Repeat Buyers')

#Get the distinct customer count for each group
customer_type_count = numberoforders_by_customers['customer_type'].value_counts()

#Visualization with Pie Chart
plt.figure(figsize=(3, 3))
plt.pie(customer_type_count.values, labels=customer_type_count.index, autopct='%1.1f%%', startangle=90, colors=['#f6072b','#10780a'])
plt.title('One-time Buyers vs Repeat Buyers')
plt.show()

"""**Reviews of Mini Analysis; One Time Buyers vs Repeating Customers**
> This outputs shows that significant amount of customers are one-time buyers with 96.9% rate and 3.1% of customers placed more than one orders.

>Based on these numbers; Customers do not order another products from Olist Market. This situation could indicate poor product and services or insufficent marketing operations.

> To solve this problem and make customers repeat purchase again; loyalty or reward programs can be published, marketing investment can be increased such as digital ads or email marketing to appeal one-time buyers with special offers.

## **5.2. Exploring of df_geolocations**
"""

print("Head 5 examples of Geolocation Data: \n")
df_geolocation.head(5)

print("Tail 5 examples of Geolocation Data: \n ")
df_geolocation.tail(5)

#The rows and columns number
print("The shape of the Geolocation table: ", df_geolocation.shape)

#Check duplicates
print("Duplicated rows number for Geolocation dataset is: ", df_geolocation.duplicated().sum())

#Check missing values
print("The missing values of Geolocation dataset: \n ")
df_geolocation.isnull().sum()

#Remove Duplicates;
print("Number of rows before removing duplicates are: ", df_geolocation.shape[0])
df_geolocation.drop_duplicates(inplace=True)
print("Number of rows after removing duplicates are: ", df_geolocation.shape[0])

#Check data type for each columns
print("The data type of each columns of Geolocation table is: \n")
df_geolocation.info()

#rename the columns;
df_geolocation.rename(columns={"geolocation_zip_code_prefix":"zip_code",
                               "geolocation_lat":"lat",
                               "geolocation_lng":"long"},inplace=True)

#Checking of multiple location entries for the same zip code
df_geolocation.groupby("zip_code").value_counts().head(5)

#to handle these multiplication, average latitude and longtitude values are used
df_geolocation=df_geolocation.groupby("zip_code").agg({"lat":"mean","long":"mean"}).reset_index()

"""### **5.2.1. Combine df_customer and df_geolocation**

> df_customers and df_geolocation tables have common columns such as city, state, zip code. Latitude and Longitude informations will be added to df_customer dataframe by using "zip_code".

> First and foremost, I will check data discrepancy between two tables, based on the results two table will be merged.
"""

#Check whether each zip code in the df_customers matches with df_geolocation dataframe or not?
unmatched_rows= df_customers[~df_customers["zip_code"].isin(df_geolocation["zip_code"])]
print("How many orders do not have latitude and longtide information? ",unmatched_rows.shape[0])
print("How many customers do not have latitude and longitude information? ",unmatched_rows["customer_unique_id"].nunique())
print("Percentage of orders with missing location information compared to all orders.",
      f"{(unmatched_rows.shape[0]/df_customers['customer_id'].nunique())*100:.2f}%")
print("Percentage of customers with missing location information compared to all customers",
      f"{(unmatched_rows['customer_unique_id'].nunique()/df_customers['customer_unique_id'].nunique())*100:.2f}%")

"""> There are 278 unmatched rows for 269 distinct customers. For those customers and orders we lack latitude and longtide information although we have state and city informations of them. The percentage is of these rows is negligible. (0.28%)"""

#Merge tables
df_customers= pd.merge(df_customers, df_geolocation[["zip_code","lat","long"]], on='zip_code', how='left')

#Checking duplication after merging
df_customers.duplicated().sum()

"""### **5.2.2. Mini Analysis; Customer Count, Order Count and Average Order Count based on Regions**"""

print("Number of distinct customer states: ",df_customers["customer_state"].nunique())
print("Number of distinct customer cities: ",df_customers["customer_city"].nunique())

#To understand the potential of each region, summary dataframe needs to be created
#This dataframe basically represent that distinct customer count, order count based on state and city
summary_geographic_base= df_customers.groupby(["customer_state","customer_city"]).agg({"customer_unique_id":"nunique",
                                                              "customer_id":"nunique"}).sort_values(by="customer_unique_id",ascending=False).reset_index()
#Rename the columns
summary_geographic_base.rename(columns={"customer_unique_id":"distinct_customer_count",
                                         "customer_id":"order_count"}, inplace=True)

#Average Order Count helps to understand customer behaiviors in the regions.
summary_geographic_base["average_order_count"]= summary_geographic_base["order_count"]/summary_geographic_base["distinct_customer_count"]

summary_geographic_base.head()

#Descriptive analysis of average_order_count to understand distributions of it.
summary_geographic_base["average_order_count"].describe().to_frame().T

#Put the distribution of average_order_count into histogram to see descriptive analysis deeply.
plt.figure(figsize=(10,6))
sns.histplot(summary_geographic_base["average_order_count"], bins=60, kde=True)
plt.title('Distribution of Average Order Count for Regions')
plt.xlabel('Average Order Counts')
plt.ylabel('Frequency')
plt.show()

"""> Based on descriptive analysis of "average_order_count" and histogram, several cities and states have only one distinct customer, and their average order count is 1. The fact that 75% of the regions have an average order count of 1. These regions has low customer engagement. These customers purchased products from Olist Market one time, and no repeat shopping.

>These cities and regions might represent locations where Olist hasn't effectively penetrated the market, customers have no information about the company or where demand for products is really low.


> Olist should focus on customer retention strategies to encourage repeat purchases, as most customers are only ordering once.




"""

#the cities are to be labeled based on average_order_count such as "One-Time Buyers", "Occasional Buyers", "Frequent Buyers"
#One-Time Buyers: average_order_count == 1, Cities/regions where customers place only a single order.
#Occasional Buyers: average_order count between 1 and 2; 1 < average_order_count <= 2, Cities/regions where customers place slightly more than one order, but not frequently.
#Frequent Buyers: the regions has average_order_count value more than 2, customers tend to make multiple purchases.

summary_geographic_base['city_category'] = summary_geographic_base['average_order_count'].apply(lambda x: 'One-Time Buyers' if x == 1
                                                 else 'Occasional Buyers' if 1 < x <= 2
                                                 else 'Frequent Buyers')

print("Number of One-Time Buyers cities in the dataset: ",summary_geographic_base[summary_geographic_base["city_category"]=="One-Time Buyers"][["customer_city"]].drop_duplicates().shape[0])
print("Number of Occasional Buyers cities in the dataset: ",summary_geographic_base[summary_geographic_base["city_category"]=="Occasional Buyers"][["customer_city"]].drop_duplicates().shape[0])
print("Number of Frequent Buyers cities in the dataset: ",summary_geographic_base[summary_geographic_base["city_category"]=="Frequent Buyers"][["customer_city"]].drop_duplicates().shape[0])

df_pie = pd.DataFrame({'city_category': ["One-Time Buyers", "Occasional Buyers", "Frequent Buyers"],
                   'count': [summary_geographic_base[summary_geographic_base["city_category"]=="One-Time Buyers"][["customer_city"]].drop_duplicates().shape[0],
                            summary_geographic_base[summary_geographic_base["city_category"]=="Occasional Buyers"][["customer_city"]].drop_duplicates().shape[0],
                             summary_geographic_base[summary_geographic_base["city_category"]=="Frequent Buyers"][["customer_city"]].drop_duplicates().shape[0]]})

df_pie.plot.pie(y='count', labels=df_pie['city_category'], autopct='%1.1f%%')
plt.title('City Categories')
plt.show()

print("One Time Buyers Cities: \n")
print(", ".join(summary_geographic_base[summary_geographic_base["city_category"]=="One-Time Buyers"]["customer_city"].values))

print("Occasional Buyers Cities: \n")
print(", ".join(summary_geographic_base[summary_geographic_base["city_category"]=="Occasional Buyers"]["customer_city"].values))

print("Frequent Buyers Cities: \n")
print(", ".join(summary_geographic_base[summary_geographic_base["city_category"]=="Frequent Buyers"]["customer_city"].values))

"""**One Time Buyers Cities;** %81.3 of the cities has a one-time buyer customer behaivior. Significant portion of the cities in this category. This category is promising. Olist should consider to publish new sales techniques and increase customer retention which resonates well with profitabilities in the future sales.

**Occasional Buyers Cities;** %18.6 of the cities has a occasional buyer customer behaivior(778 cities in the dataset).These cities have customers who have made a few purchases, but not enough to be considered frequent buyers. For these category Olist should aim to convert these customers into frequent buyers.


**Frequent Buyers Cities;** Frequent buyer cities account for only 2 cities in the dataset. These cities have customers who have made multiple purchases, they have a relatively strong relationship with the Olist.
Olist can focus on strategies that reward and engage loyal customer in order to maintain and grow the customer base in frequent buyer cities,

## **5.3. Exploring of df_products**
"""

print("Head 5 examples of Product Data: \n")
df_products.head(5)

print("Tail 5 examples of Product Data: \n ")
df_products.tail(5)

#The rows and columns number
print("The shape of the Product table: ", df_products.shape)

#Check duplicates
print("Duplicated rows number for Product dataset is: ", df_products.duplicated().sum())

#Check missing values
print("The missing values of Product dataset: \n ")
df_products.isnull().sum()

"""**Handling with missing values;**

>product_name_lenght, product_description_lenght, product_photos_qty columns will not be used for analysis. These columns will be removed.

>product_category_name and the metrics related size of the products are important features.

> Size metrics; product_weight_g, product_length_cm, product_height_cm, product_width_cm have 2 rows missing values, these values will be fill with zero.

>For category_name; Based on its impacts on order table, this rows will be deleted or filled with values.
"""

#define product_id values for missing category_names
missing_products=df_products[df_products["product_category_name"].isnull()]["product_id"].reset_index()

#calculate orders price for missing categories.
missing_categories_price=df_order_items[df_order_items["product_id"].isin(missing_products["product_id"])]["price"].sum()

#calculate total price regardless of product details.
total_price=df_order_items["price"].sum()

#calculate percentage of total sales
impact_of_missing = (missing_categories_price/total_price)*100
print("Percentage of total sales contributed by products that do not have a product category: "f"{impact_of_missing:.2f}%")

"""The impact of null product categories (1.32 %) can be negligible. Null values will be replaced "Other" categories.

"""

#fill null values with "Others"
df_products["product_category_name"].fillna("Others",inplace=True)
df_products[["product_weight_g","product_length_cm","product_height_cm", "product_width_cm"]] = df_products[["product_weight_g","product_length_cm","product_height_cm", "product_width_cm"]].fillna(0)

#drop unnecessary columns
df_products.drop(columns=["product_name_lenght","product_description_lenght","product_photos_qty"],inplace=True)

#missing value check
df_products.isnull().sum()

df_products.info()

#Check data type for each columns
print("The data type of each columns of product table is: \n")
df_products.info()

"""### **5.3.1. Mini Analysis: Measuring Category Variety**

The aim of this section is analyzed to the Olist Market's product categories variety.

What categories have the most different types of product?
"""

#create a summary dataframe to analyze category variety
category_summary= df_products.groupby("product_category_name").agg({"product_id":"count"}).rename(columns={"product_id":"count"}).reset_index()

category_summary.sort_values(by="count",ascending=False,inplace=True)

#mean value will be used to compare product variety
mean_of_product_count=category_summary['count'].mean()

plt.figure(figsize=(12, 25))
ax = sns.barplot(y="product_category_name", x="count", data=category_summary, palette="coolwarm")
plt.title("Distinct Product Count for each Category")
plt.xticks(rotation=90)
plt.xlabel("Distinct Product Count")
plt.ylabel("Product Category")

#Add constant line as vertically to show mean of the product number for comparison
ax.axvline(x=mean_of_product_count, label="Average Product Count", color="r", linestyle="--")

#I want to see mean value in the middle of the constatn line therefore I am gonna calculate the middle poit by getting minimum and maximum value of y axis
#Get the y-axis limits
yminimum_, ymaximum_ = ax.get_ylim()

#Calculate the midpoint of the y-axis range
y_middle_ = (yminimum_ + ymaximum_) / 2

#Annotate the mean value in the middle of the constant vertical line
ax.text(mean_of_product_count, y_middle_, f"Average Product Count = {mean_of_product_count:.1f}",
        color='r', fontsize=10, verticalalignment='center', horizontalalignment='left', rotation=90)

#Add Product Count Numbers as text on the bars
for p in ax.patches:
    width = p.get_width()
    y = p.get_y()
    if not isinstance(y, (int, float)):
        y = float(y)
    plt.text(width + 10, y + p.get_height() / 2, '{:.2f}'.format(width), ha="left", va="center")

plt.tight_layout()
plt.show()

#List of the product categories has product variety more than average.
print("Product categories has product variety more than average: \n")
display(category_summary[category_summary["count"]>mean_of_product_count]["product_category_name"].to_list())

#I want to see distinct total category name
print("Distinct category name count : ", category_summary["product_category_name"].nunique())

"""> Olist offers different types of products to market and this is really hard to manage. It requires different perspectives, dealing with different sellers and each product requires different operational structure.


> Some product categories have wide range of products. Especially **cama_mesa_banho, esporte_lazer, moveis_decoracao, beleza_saude, utilidades_domesticas** product categories offer more then 2000 different product to the market. Olist can create competitive advantages through personolization for these categories. For those categories, Olist can make use of recommendation engines to promote this products efficiently. But the potentian risk of these categories is possibility of making customers confusing and leading to indesicion.



> Some categories have relatively less variety such as **cine_foto, musica, fashion_roupa_feminina** etc. (the value of distinct product count less than 30). By considering these categories sales, sales strategies such as sales with bundles or focus on product quality can be developed.

## **5.4. Exploring of df_sellers**
"""

print("Head 5 examples of sellers Data: \n")
df_sellers.head(5)

print("Tail 5 examples of sellers Data: \n")
df_sellers.tail(5)

#The rows and columns number
print("The shape of the seller table: ", df_sellers.shape)

#Check duplicates
print("Duplicated rows number for seller dataset is: ", df_sellers.duplicated().sum())

#Check missing values
print("The missing values of seller dataset: \n ")
df_sellers.isnull().sum()

"""There is no need to clean this data."""

#Check data type for each columns
print("The data type of each columns of seller table is: \n")
df_sellers.info()

#change the name of columns to increase readability
df_sellers.rename(columns={"seller_zip_code_prefix":"zip_code"},inplace=True)

"""### **5.4.1. Pulling Latitude and Longitude Informations from df_geolocations**"""

#df_geolocation and df_Sellers will be joined using zip_code column.
#First things to do is checking zipcode mismatch situations
#Are there any zipcodes that are in df_sellers but not in df_geolocation
zipcode_mismatch= df_sellers[~df_sellers["zip_code"].isin(df_geolocation["zip_code"])]
print("The number of mismatching zipcodes: ", zipcode_mismatch.shape[0])
print("Percentage of mismatching zipcodes compared to all zipcodes: " ,f"{(zipcode_mismatch['zip_code'].nunique()/df_sellers['zip_code'].nunique())*100:.2f}%")

#As the percentage rate of mismatching rows is 0.31%, these rows are ignored
df_sellers= pd.merge(df_sellers, df_geolocation[["zip_code","lat","long"]], on='zip_code', how='left')

#Check duplication after merge
df_sellers.duplicated().sum()

"""### **5.4.2. Mini Analysis: Seller Locations vs Customers Locations**"""

#Summary
print("Number of distinct sellers: ",df_sellers["seller_id"].nunique())
print("Number of distinct seller states: ",df_sellers["seller_state"].nunique())
print("Number of distinct seller cities: ",df_sellers["seller_city"].nunique())
summary_seller=df_sellers.groupby("seller_state").agg({"seller_id":"nunique"}).sort_values(by="seller_id",ascending=False).reset_index()

"""> Based on earlier findings, from Exploring of df_customer & df_geolocation sections, We can tell that Olist has 96096 different customers and those customers live in 27 different states and 4119 different cities which indicates that there are states and cities that Olist has customer but not has sellers.

"""

#determine cities and states where does not have sellers.
noseller_states= df_customers[~df_customers["customer_state"].isin(df_sellers["seller_state"])][["customer_state"]].drop_duplicates()
noseller_cities= df_customers[~df_customers["customer_city"].isin(df_sellers["seller_city"])][["customer_state","customer_city"]].drop_duplicates()

print("Number of states that Olist has customers but not has sellers: ",noseller_states.shape[0])
print("List of the states that Olist has customers but not has sellers:")
print(noseller_states["customer_state"].to_list())

print("Number of cities that Olist has customers but not has sellers: ",noseller_cities["customer_city"].nunique())
print("List of the cities that Olist has customers but not has sellers:")
print(", ".join(noseller_cities["customer_city"].to_list()))

#Discover the potential of these states by using customer count, order count and average order count.
customer_summary=df_customers.groupby(["customer_state"]).agg({"customer_unique_id":"nunique",
                                              "customer_id":"nunique"}).sort_values(by="customer_unique_id",ascending=False).reset_index()
customer_summary.rename(columns={"customer_unique_id":"distinct_customer_count",
                                         "customer_id":"order_count"}, inplace=True)
customer_summary["average_order_count"]= customer_summary["order_count"]/customer_summary["distinct_customer_count"]

#The list of states that Olist has no seller but sales.
customer_summary[customer_summary["customer_state"].isin(noseller_states["customer_state"])]

"""> Olist has a potential customer base in the following regions; AL, TO, AP, RR. Having a seller in these states can significantly increase the sales amount, expend customer base and reduce shippment costs and delivery time can be shortened by improving operational efficiency.

"""

#Discover the potential of cities where have no seller by using customer count, order count and average order count.
customer_summary_city=df_customers.groupby(["customer_city"]).agg({"customer_unique_id":"nunique",
                                              "customer_id":"nunique"}).sort_values(by="customer_unique_id",ascending=False).reset_index()
customer_summary_city.rename(columns={"customer_unique_id":"distinct_customer_count",
                                         "customer_id":"order_count"}, inplace=True)
customer_summary_city["average_order_count"]= customer_summary_city["order_count"]/customer_summary_city["distinct_customer_count"]

#List of the cities that do not have seller
print("Cities has no sellers but sales: \n")
potential_cities=customer_summary_city[customer_summary_city["customer_city"].isin(noseller_cities["customer_city"])].sort_values(by="order_count",ascending=False)
potential_cities[potential_cities["order_count"]>50]

"""Especially **Belem** has a strong potential customer base. Moreover, several cities show pattern of repeat customer based on average order count. Enhancing seller presence in these cities could enhance this relatively royal customer base, increase sales and improving long-term customer retention.

## **5.5. Exploring of Order DataFrames**

###**5.5.1. Exploring df_orders**
"""

print("Head 5 examples of orders data: \n")
df_orders.head(5)

print("Tail 5 examples of orders data: \n")
df_orders.head(5)

#The rows and columns number
print("The shape of the order table: ", df_orders.shape)

#Check duplicates
print("Duplicated rows number for order dataset is: ", df_orders.duplicated().sum())

#Check missing values
print("The missing values of order dataset: \n ")
df_orders.isnull().sum()

"""**Dealing with missing value**

As "order_approved_at", "order_delivered_carrier_date" will not be used in further analysis, they will be dropped.

In further analysis will be carried out for only "delivered" orders. Therefore, rows from other order status will be deleted.
"""

#check the order status value first for missing "order_delivered_customer_date". Based on order status value I will decide whether remove missing rows or not.
df_orders[df_orders["order_delivered_customer_date"].isnull()]["order_status"].value_counts()

#In this notebook I will focus on only "delivered" orders. For the other types it is too normal to not have order_delivered_customer_date
#I will drop rows which order status is not equal to "delivered"
df_orders=df_orders[df_orders["order_status"]=="delivered"]

#fill the missing delivered times with estimated delivery date (only 8 rows are missing)
df_orders["order_delivered_customer_date"].fillna(df_orders["order_estimated_delivery_date"],inplace=True)

#Remove unnecessary columns
df_orders.drop(columns=["order_approved_at","order_delivered_carrier_date","order_estimated_delivery_date"],inplace=True)

#Check missing rows again.
print("Missing rows number for order dataset is: ", df_orders.isnull().sum())

"""### **5.5.2. Exploring df_order_items**"""

print("Head 5 examples of orders items data: \n")
df_order_items.head(5)

print("Tail 5 examples of orders items data: \n")
df_order_items.tail(5)

#The rows and columns number
print("The shape of the order items table: ", df_order_items.shape)

#Check duplicates
print("Duplicated rows number for order items dataset is: ", df_order_items.duplicated().sum())
#Check missing values
print("The missing values of order items dataset: \n ")
df_order_items.isnull().sum()

#remove unnecessary column
df_order_items.drop(columns=["shipping_limit_date","order_item_id"],inplace=True)

"""The order items dataframe has no missing or duplicated values, therefore, there is no needed to cleaning dataframe.

### **5.5.3. Combining df_orders and df_order_items**

>df_orders has order id, customer id, date and time information of order

>df_order_items has order id, product id and seller id and values of orders such as shipment cost and price

>By merging two order dataframes, I aim to consolidate all information into one dataframe.

>Before merging two dataframe, first order_item_id dataframe will be summarized and total order value will be calculated based on freight and price of each product.
"""

#get backups
df_orders_backup=df_orders.copy()
df_order_items_backup=df_order_items.copy()

#create an item column to calculate how many products were bought
df_order_items["item"] = df_order_items.groupby(['order_id', 'product_id'])['product_id'].transform('size')

#For each order and different product there will be only one row on the order dataframe
df_order_items= df_order_items.drop_duplicates().reset_index()

#Rename the columns
df_order_items=df_order_items.rename(columns={"price":"Unit_Price", "freight_value":"Freight_Value", "item":"Total_Item"})

#Total Price are calculated each product's price multiplied by total item.
df_order_items['Total_Price'] = df_order_items ["Unit_Price"] *df_order_items ["Total_Item"]
#Total Value of the order equals to summation of Total Price and Shipment Value.
#The total order value (product + freight)
df_order_items['Total_Order_Value'] = df_order_items["Total_Price"] + df_order_items["Freight_Value"]
#At the end we have a df_order_items represents total price, unit price, freight value, total item number and total order value based on product, seller and order id.

#remove index columns
df_order_items = df_order_items.drop(["index"],axis=1)

#Check if there are mismatched order id between df_order and df_order_items

# Merge customer_id into df_order_items
df_order_details = df_order_items.merge(df_orders[["order_id", "customer_id"]], on="order_id", how="left")

#Check if all order_ids in df_order_items have a match in df_orders
missing_order_ids_in_orders = df_order_details[df_order_details['customer_id'].isnull()]

if not missing_order_ids_in_orders.empty:
    print("These order_id are in the df_order_items do not have a matching order in df_orders:")
    print(missing_order_ids_in_orders[['order_id']])
else:
    print("All order_id are in the df_order_items are matched in df_orders.")

#Check if all order_ids in df_orders have a match in df_order_items
missing_order_ids_in_order_items = df_orders[~df_orders['order_id'].isin(df_order_items['order_id'])]

if not missing_order_ids_in_order_items.empty:
    print("\nThese order_id are in the df_orders do not have a matching entry in df_order_items:")
    print(missing_order_ids_in_order_items[['order_id']])
else:
    print("\nAll order_id are in the df_orders have matching entries in df_order_items.")

# Resulting DataFrame with customer_id added
print("\nMerged df_order_details:")
print(df_order_details)

#These order_id have no equivilant order_id in df_orders dataframe.
#For that reason, these order_id has no customer_id, order_date informations.
missing_order_ids_in_orders.head(5)

#Ratio of missing_order_id sales to all sales
missing_order_ratio= (missing_order_ids_in_orders["Total_Order_Value"].sum() / df_order_items["Total_Order_Value"].sum())*100
print("Ratio of missing_order_id sales to all sales: ",f"{missing_order_ratio:.2f}%")

"""> To sum up; There are some order_id which exist in df_order_items but not in df_orders dataframe. For these unmatching order_id's unfortunately, there are no customer information, order date and delivering day informations. These informations cannot be filled with any prediction method. Additionally, The ratio of these unmatching orders to all orders is 2.68%, which is not that high. Because of all the reasons just listed, these orders will not take place in the final, merged, order dataframe.


"""

#Merged two dataframe and create final dataframe.
df_final_orders= pd.merge(df_order_items, df_orders[['order_id', 'customer_id', "order_purchase_timestamp","order_delivered_customer_date"]], on='order_id', how='inner')

"""# **Business Questions**

## **Question 1: Sales Trend Analysis**

**Question:** How sales trends developed over time? Are there any seasonal patterns?

> Order date and sales values (quantity, order count, revenu) will be used to detect a seosonality.

>First step is to create new dataframe which includes date and sales values.
"""

#Drop columns that will not be used
trend_analysis=df_final_orders.drop(columns=["product_id","seller_id","order_delivered_customer_date"])

#Create Date, Year, Month columns to use in time based analysis accurately.
#Convert the order purchase timestamp to a datetime
trend_analysis['order_purchase_timestamp'] = pd.to_datetime(trend_analysis['order_purchase_timestamp'])
trend_analysis['order_year'] = trend_analysis['order_purchase_timestamp'].dt.year
trend_analysis['order_month'] = trend_analysis['order_purchase_timestamp'].dt.month
trend_analysis['order_purchase_date'] = pd.to_datetime(trend_analysis['order_purchase_timestamp']).dt.date

#Determining the date range to be analyzed
#Create new dataframe represents how many orders take place in a month and how many days have order records
date_check=trend_analysis.groupby(["order_year","order_month"]).agg({"order_id":"count",
                                                           "order_purchase_date":"nunique"}
                                                          ).reset_index().sort_values(by=["order_year", "order_month"], ascending=True)

#List of months with less than 26 days order record.
#These records will be deleted because they break constant order line
date_check[date_check["order_purchase_date"]<26]

#Remove rows from 2016.
trend_analysis= trend_analysis[~(trend_analysis['order_year'] == 2016)]

"""**KPI list to measure monthly sales;**
* **Total Order Value**: How much money generated?
* **Distinct Order Count**: How many orders did take place?
* **Average Order Value**: What is the average revenue per order?
* **Daily Average Value**: What is the average revenue per day?
* **Total Order Value Growth by Previous Month** : What is the growth rate compared to previous month?
* **Order Count Growth by Previous Month**:  What is the growth rate compared to previous month?
* **Average Order Value Growth by Previous Month** :  What is the growth rate compared to previous month?
* **Daily Average Value Growth by Previous Month** :  What is the growth rate compared to previous month?


"""

#Create a summary dataframe along with KPI's to analyze data deeply
monthly_summary= trend_analysis.groupby(['order_year', 'order_month']).agg({"Total_Order_Value":"sum",
                                                  "order_id":"nunique",
                                                   "order_purchase_date":"nunique"
                                                  }).reset_index()
monthly_summary["Avreage_Order_Value"]=monthly_summary["Total_Order_Value"]/monthly_summary["order_id"]
monthly_summary["Daily_Average_Value"]=monthly_summary["Total_Order_Value"]/monthly_summary["order_purchase_date"]
monthly_summary["TOV_Growth_PM"]=monthly_summary['Total_Order_Value'].pct_change() * 100
monthly_summary["OrderCount_Growth_PM"]=monthly_summary['order_id'].pct_change() * 100
monthly_summary["AOV_Growth_PM"]=monthly_summary['Avreage_Order_Value'].pct_change() * 100
monthly_summary["DAV_Growth_PM"]=monthly_summary['Daily_Average_Value'].pct_change() * 100

#rename columns
monthly_summary.rename(columns={"order_id":"Order_Count",
                                "order_purchase_date":"Day Count"},inplace=True)

#Visualize the output
plt.style.use('seaborn-darkgrid')
fig, ax = plt.subplots(3, 1, figsize=(12, 12))

#Plot Total Order Value over time
sns.lineplot(data=monthly_summary, x='order_month', y='Total_Order_Value', hue='order_year', marker='o', ax=ax[0])
ax[0].set_title('Total Order Value by Year and Month', fontsize=14)
ax[0].set_ylabel('Total Order Value')

#Annotate TOV_Growth_PM for each month
for i, row in monthly_summary.iterrows():
    ax[0].annotate(f'{row["TOV_Growth_PM"]:.2f}%',
                 xy=(row['order_month'], row['Total_Order_Value']),
                 xytext=(10, 10), textcoords='offset points')


#Plot Growth for Total Order Value over time
sns.lineplot(data=monthly_summary, x='order_month', y='Order_Count', hue='order_year', marker='o', ax=ax[1])
ax[1].set_title('Distinct Order Count by Year and Month', fontsize=14)
ax[1].set_ylabel('Order_Count')

#annotate Order_Value_Growth for each month
for i, row in monthly_summary.iterrows():
    ax[1].annotate(f'{row["OrderCount_Growth_PM"]:.2f}%',
                 xy=(row['order_month'], row['Order_Count']),
                 xytext=(10, 10), textcoords='offset points')

#Plot Daily Average Value over time
sns.lineplot(data=monthly_summary, x='order_month', y='Daily_Average_Value', hue='order_year', marker='o', ax=ax[2])
ax[2].set_title('Daily Average Value by Year and Month', fontsize=14)
ax[2].set_ylabel('Daily Average Value')

#Annotate DAV_Growth for each month
for i, row in monthly_summary.iterrows():
    ax[2].annotate(f'{row["DAV_Growth_PM"]:.2f}%',
                 xy=(row['order_month'], row['Daily_Average_Value']),
                 xytext=(10, 10), textcoords='offset points')

plt.tight_layout()
plt.show()

"""### **Observations**

> The graphs clearly shows a significant increase in sales from 2017 to 2018 in all metrics. It’s crucial to maintain this momentum by continuing to invest in marketing, sales and operation optimization strategies.

> **Peak Periods:** It is clear that November is the strongest month, probably due to Black Friday. Additionally, March has also a notable peak.
2018 January sales shows positive growth compared to last year's December.

> **Slower Periods:** June, July, and December show slower growth or declines. For these months, marketing campaign should be prioritized to prevent sales decrease.

> November 2017 has a significant boost in the three line charts, indicating a high seasonal demand due to Black Friday or other promotions. Total Order Value growth is 53.41%, Order Count growth is 62.77% and Daily Average Value growth is 58.53% from October to November 2018.

>There is a sharp decline from November to December. December 2017 see a -26.59 % drop in Total Order Value indicating the market reach a short term saturation after November discounts. Offering promotions beyond Black Friday might help reduce the steep decline and increase sales.

>2018 January has 27.62% decrease in Total Order Value compared to last year's December, suggesting that the New Year holiday shopping season over in December but increase emerges in January again.


>Three metrics(Total Average Value, Daily Average Value, Order Count) along with growth rates increase through early spring (March 2018 has a 15.97% increase), but this growth is getting slow in April and May.

## **Question 2: Delivery Performance Analysis**

**Question**: What is the average elapsed time from order placement time to delivery in different regions? Are there regions or sellers where delivery times are mostly longer?

Customer Regions, Seller Regions, Order Purchase Date, Order Delivered Date will be used for this analysis.

First step is create a summary dataframe to use during analyzing and visualizing the data.
"""

#Get customer location information from customer table
summary_df= df_final_orders[["order_id","seller_id","customer_id","order_purchase_timestamp","order_delivered_customer_date"]].merge(df_customers[["customer_id","customer_state","customer_city","lat","long"]],on="customer_id",how="inner")

#Get seller location information from seller dataframe
summary_df=summary_df.merge(df_sellers[["seller_city","seller_state","lat","long","seller_id"]],on="seller_id",how="inner")

#adjust date columns
summary_df["order_purchase_timestamp"]=pd.to_datetime(summary_df["order_purchase_timestamp"])
summary_df["order_delivered_customer_date"]=pd.to_datetime(summary_df["order_delivered_customer_date"])

#rename columns
summary_df.rename(columns=({"order_purchase_timestamp":"order_date",
                            "order_delivered_customer_date":"delivered_date",
                            "lat_x":"lat_customer",
                            "long_x":"long_customer",
                            "lat_y":"lat_seller",
                            "long_y":"long_seller"}),inplace=True)

#calculate the date difference between order date and delivered date
summary_df['duration'] = (summary_df['delivered_date'] - summary_df['order_date']).dt.days

#Calculate the distance between Customer and Seller.
#Haversine formula will be used to calculate the distance between two differen locations.
def haversine(lat1, lon1, lat2, lon2):
    # Radius of Earth in kilometers
    R = 6371.0

    #Convert latitude and longitude from degrees to radians
    lat1 = np.radians(lat1)
    lon1 = np.radians(lon1)
    lat2 = np.radians(lat2)
    lon2 = np.radians(lon2)

    #Calculate differences between latitudes and longitudes
    dlat = lat2 - lat1
    dlon = lon2 - lon1

    #application of Haversine formula
    a = np.sin(dlat / 2.0) ** 2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon / 2.0) ** 2
    c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1 - a))

    #Final results of distance in kilometers
    distance = R * c
    return distance

#appylying the haversine function to each row in 'order' dataframe
summary_df['distance_km'] = summary_df.apply(lambda row: haversine(row['lat_seller'], row['long_seller'], row['lat_customer'], row['long_customer']), axis=1)

summary_df.describe().T

#To analyze the distribution of duration.
sns.histplot(summary_df['duration'], bins=20, kde=True)

"""Based on histogram and desriptive analysis;
> The mean delivery duration is about 12 days, with a wide range (from 0 to 209 days). This also indicates that there are possible outliers.

> The mean distance between customers and sellers is roughly 599 km, ranging from 0 km to over 8,600 km.

>The standard deviation for both duration and distance_km is relatively high.

### **Q2: Investigation of Outliers**

1. First and foremost I checked the data that has longest delivery time and compared this data with the similar data.

2. I created boxplot to analyze outliers better.

3. I applied 4 different "Outlier Detection Methodology" and compared the results of them.

4. I choose the most effective outlier detection method for duration time.
"""

#Investigation of Outliers
# I just want to check the seller that has the longest delivery time to understand the possibility of mistake
#This seller has only one orders and I checked smillar orders and found out that the mean value of delivery time for similar order is 9.7 days
#Therefore, This order should be considered as an outlier.
display(summary_df[summary_df['seller_id']=="df683dfda87bf71ac3fc63063fba369d"].head(5))
#similar orders average delivery time
print("The average delivery time for similar orders;",
       summary_df[(summary_df['distance_km'] > 800) &
       (summary_df['customer_state'] == "SP")&
       (summary_df['seller_state'] == "RS")]["duration"].mean())

#create a different variables to use during outliers detection methods.
df=summary_df

"""**Apply Isolation Forest (Machine Learning Based) to outlier detection**"""

#Isolation Forest (Machine Learning Based)
#Isolation Forest is an unsupervised machine learning algorithm designed to detect anomalies.
from sklearn.ensemble import IsolationForest

iso_forest = IsolationForest(contamination=0.01, random_state=42)

#Fit the model and predict outliers
df['anomaly'] = iso_forest.fit_predict(df[['duration']])

#Detect outliers, outliers will be represented as -1
outliers = df[df['anomaly'] == -1]

#List outliers
print(outliers["duration"].min())

"""**Apply MAD (Median Absolute Deviation) Method to outliers detection**"""

#MAD (Median Absolute Deviation)
#calculate the median absolute deviation
median_duration = df['duration'].median()
mad_duration = (df['duration'] - median_duration).abs().median()

#define outliers
outliers = df[(df['duration'] - median_duration).abs() > 3 * mad_duration]

#Show outliers
print(outliers["duration"].min())

"""**Apply Z-Score Method to outliers detection**"""

#Z-Score Method
from scipy import stats

#Calculate Z-scores
df['zscore_duration'] = stats.zscore(df['duration'])

#Define threshold for outliers
threshold = 3

#Detect outliers based on Z-score
outliers = df[(df['zscore_duration'].abs() > threshold)]

#show outliers
print(outliers["duration"].min())

"""**Apply IQR(Interquartile Range) Method to outliers detection**"""

#IQR Method
# Calculate Q1 (25th percentile) and Q3 (75th percentile)
Q1 = df['duration'].quantile(0.25)
Q3 = df['duration'].quantile(0.75)

# Calculate IQR
IQR = Q3 - Q1

# Define the lower and upper bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Detect outliers
outliers = df[(df['duration'] < lower_bound) | (df['duration'] > upper_bound)]

# Show outliers
print(outliers["duration"].min())

"""**Comparing Results and Making Last Desicion**"""

#Create boxplot before identify outliers
#Original Data with outliers
sns.boxplot(df["duration"])
plt.title('Boxplot of Delivery Duration')

import matplotlib.pyplot as plt

# Assuming your duration data and outlier-detected versions are already available
# Here are example variables for each set of data:
# duration_original, duration_isolation_forest, duration_mad, duration_zscore, duration_iqr

# Create a 2x2 grid of subplots
fig, axes = plt.subplots(2, 2, figsize=(12, 8))

# Plot 4 boxplots in the 2x2 grid
axes[0, 0].boxplot(df[df["anomaly"]==1]["duration"])
axes[0, 0].set_title('Boxplot of Delivery Duration (Isolation Forest)')

axes[0, 1].boxplot(df[~(df['zscore_duration'].abs() > threshold)]["duration"])
axes[0, 1].set_title('Boxplot of Delivery Duration (Z Score)')

axes[1, 0].boxplot(df[((df['duration'] - median_duration).abs() <= 3 * mad_duration)]["duration"])
axes[1, 0].set_title('Boxplot of Delivery Duration (MAD)')

axes[1, 1].boxplot(df[df["duration"]<29]["duration"]) #IQR method define 28 as a treshold for outliers
axes[1, 1].set_title('Boxplot of Delivery Duration (IQR)')


plt.tight_layout()
plt.show()

"""**Observations**

1. The first boxplot with "Boxplot of Delivery Duration" headline shows the duration data with many extreme outliers (original data), the one that gets the most attention is the one with a value of over 200 days. Along with descriptive analysis, we can say that these extreme values are likely not normal and may indicate operational delays or data entry errors.

2. The Isolation Forest method includes some outliers, but less than the raw data. The distribution still has a large number of data points outside the box.

3. Z-Score method  removed more outliers than Isolation Forest but our data distribution does not fit with the normal distribution. It is skewed, therefore, this method might not be the best solution.

4. MAD removed more outliers than the previous methods but it still preserves longer duration days such as 20.

5. IQR  shows a moderate number of outliers, with a slightly higher number on the upper side compared to MAD.

Since our data is skewed I believe that MAD or IQR may be a good option in case of handling outliers without removing long delivery durations. My goal is to identify outliers while keeping long delivery duration, I will flag outliers based on IQR method.

**Flag Outliers**
"""

# Flag outliers using a lambda expression
summary_df["outlier_flag"] = (summary_df['duration'] < lower_bound) | (summary_df['duration'] > upper_bound)
summary_df["outlier_flag"] = summary_df["outlier_flag"].map(lambda x: 'outlier' if x else 'non-outlier')

"""### **Visualize Outliers**"""

#Create a dataframe for outliers
outliers_df = summary_df[summary_df['outlier_flag'] == "outlier"]

# Group by seller and customer states to analyze performance by creating average duration, standard deviation of duration and distance
outlier_summary = outliers_df.groupby(['seller_state', 'customer_state']).agg({
    'duration': ['mean', 'std', 'count'],  # Analyze average, standard deviation, and count of outliers
    'distance_km': ['mean', 'std']
}).reset_index()

# Order columns
outlier_summary.columns = ['seller_state', 'customer_state', 'avg_duration', 'std_duration', 'outlier_count', 'avg_distance', 'std_distance']

#Turn data into pivot table
pivot_table = outlier_summary.pivot(index='seller_state', columns='customer_state', values='outlier_count')

#Put data into heatmap, show outlier counts between states
plt.figure(figsize=(14, 10))

sns.heatmap(pivot_table, annot=True, cmap="Blues", fmt="g", linewidths=.5)
# rotate axis labels for better readability
plt.xticks(rotation=45, ha='right', fontsize=10)
plt.yticks(rotation=0, fontsize=10)

plt.title('Heatmap of Outlier Counts between Seller and Customer States')
plt.xlabel('Customer State')
plt.ylabel('Seller State')
plt.tight_layout()
plt.show()

# Visualizing average duration for outliers between regions
plt.figure(figsize=(14, 10))
pivot_table_duration = outlier_summary.pivot(index='seller_state', columns='customer_state', values='avg_duration')
sns.heatmap(pivot_table_duration, annot=True, cmap="Oranges", fmt=".1f", linewidths=.5)
# rotate axis labels for better readability
plt.xticks(rotation=45, ha='right', fontsize=10)
plt.yticks(rotation=0, fontsize=10)
plt.title('Heatmap of Average Duration for Outliers between Seller and Customer States')
plt.xlabel('Customer State')
plt.ylabel('Seller State')
plt.tight_layout()
plt.show()

"""> Outliers can indicate delays or anomalies in delivery performance. They may derive from data entry errors, special occasions, special circumstances such as stock out situations or holidays or transportation problems. The other reason could be the delivery time constantly long for specific sellers or regions.


> SP, PR, MG, SC and RG regions have the most outliers data (Especially from SP to RJ, indicates serious problems with shipment between this areas, average order delivery time is also more than 41 days). This indicate that there could be legitimate problems with sellers in these states instead of data entry errors. Focusing on these regions to performance improvement could be benefical. For other states the outliers might stem for wrong data entries because they have less than 10 outliers.


>Unfortunately, average time is more than 30 days for each state pairs which is obviously frustrating for e-commerce customers. I believe that the durations with dark orange background could be data entry errors since their outliers count is also less than 10. (the shipments depart from AM, BA, CE).

### **Calculating Corelation between Distance and Duration**
"""

#create a correlation matrix to examine the relationship between distance and duration time
# calculate the correlation matrix
correlation_matrix = summary_df[summary_df["outlier_flag"]=="non-outlier"][['duration', 'distance_km']].corr()

# Step 2: Visualize the correlation matrix using Seaborn heatmap
plt.figure(figsize=(8, 6))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt='.2f')
plt.title('Correlation Matrix between Delivery Duration and Distance')
plt.show()

"""The correlation between distance and delivery duration is moderate (0.45) suggesting that there are other factors effect delivery time.

Next step is defining underperforming locations by calculating standard deviotion of delivery duration by states

### **Define Underperforming Locations**
"""

# create a summary data frame without outliers
#categorize data by seller state and customer state, and calculate the mean and standard deviation of duration
state_duration_stats = summary_df[summary_df["outlier_flag"]=="non-outlier"].groupby(['seller_state', 'customer_state']).agg(
    mean_duration=('duration', 'mean'),
    std_duration=('duration', 'std'),
    count=('duration', 'size')
).reset_index()
state_duration_stats.head(5)

#There are some state pairs which have only 1 orders.
#We need to filter these orders, only include state pairs with enough data
#For filtering the state pairs that have more than 20 orders will be included
state_duration_stats = state_duration_stats[state_duration_stats['count'] > 20]
state_duration_stats.head(5)

#To visualize the data, heatmap will be created. Therefore, the data put into the pivot table
pivot_table = state_duration_stats.pivot(index='seller_state', columns='customer_state', values='std_duration')

# create a heatmap to visualize the standard deviation of delivery durations between states
plt.figure(figsize=(14, 10))
heatmap = sns.heatmap(pivot_table, annot=True, fmt='.2f', cmap='coolwarm',
                      cbar_kws={'label': 'Standard Deviation of Delivery Duration'},
                      linewidths=0.5, annot_kws={"size": 8})  # Smaller annotation size

# rotate axis labels for better readability
plt.xticks(rotation=45, ha='right', fontsize=10)
plt.yticks(rotation=0, fontsize=10)


plt.title('Standard Deviation of Delivery Duration by Seller and Customer State', fontsize=14)
plt.xlabel('Customer State', fontsize=12)
plt.ylabel('Seller State', fontsize=12)

plt.tight_layout()
plt.show()

"""**High Standard Deviation (Red Areas)**:

1.   from SP to AM (7.04)

This pair is potential area for improvement logistic strategies. Delivery times are relatively inconsistent which can negatively effect customer satisfaction.

>The sellers in SP state already have the most outlier data. Which indicates that Olist should definetly reconsider the arrangments between the sellers from SP state.


**Moderate Standard Deviation (Orange Areas)**:

1. from MG TO PA (6.40)
2. from RS to DF (6.33)
3. from RJ to PE (6.24) etc.


Most of the pairs have moderate standard deviations, these pairs of states have inconsistent delivery durations, some deliveries are quick, while others take significantly longer.

The orders departing from SP regions to all other regions have significantly inconsistent delivery time. The sellers in the SP state should be investigat or need closer monitoring or training to improve their fulfillment process. These sellers should improve their strategies.

The sellers in the SP state should be prioritized first, followed by the MG, PR, RJ and SC states.


**Low Standard Deviation (Blue Areas):**

These state pairs with consistent delivery times, which are performing well.

> I expected the delivery from the same state to the same state to perform best. However, some states performed more consistently for different states rather than themselves. For example;

* from SC to ES shows more stability than SC to SC with 4.82 vs 4.25 standard deviation
* from RS to SC than RS to RS
* from PE to BA than PE to PE
* from GO to DF than GO to GO
* from BA to MG than BA to BA





"""

#Delivery times by region

#Calculate average delivery time by customer state
avg_delivery_by_region = summary_df[summary_df["outlier_flag"]=="non-outlier"].groupby('customer_state')['duration'].mean().reset_index()
avg_delivery_by_region.columns = ['Region', 'Avg_Delivery_Time']

#Calculate average delivery time by seller
avg_delivery_by_seller = summary_df[summary_df["outlier_flag"]=="non-outlier"].groupby('seller_id')['duration'].mean().reset_index()
avg_delivery_by_seller.columns = ['Seller_ID', 'Avg_Delivery_Time']

avg_delivery_by_region.head(2)

# Visualize the delivery times by region
plt.figure(figsize=(12, 6))

#add spesific color code for each bar based on average delivery time
values = avg_delivery_by_region['Avg_Delivery_Time']
colors = ['red' if value > 20 else 'orange' if value > 10 and value <= 20 else 'green' for value in values]

ax=sns.barplot(x='Region', y='Avg_Delivery_Time', data=avg_delivery_by_region, palette=colors)

#add a constant line to show average duration days.
plt.axhline(y=summary_df[summary_df["outlier_flag"]=="non-outlier"]["duration"].mean(), color='b', linestyle='--')

#add annotation on bars
for p in ax.patches:
    ax.annotate(format(p.get_height(), '.2f'), (p.get_x() + p.get_width() / 2., p.get_height()), ha = 'center', va = 'center', xytext = (0, 10), textcoords = 'offset points')

plt.title('Average Delivery Time by Customer States')
plt.xticks(rotation=45)
plt.ylabel('Average Delivery Time (days)')
plt.xlabel('Customer States')
plt.show()

""">This barplot shows that the shipment process needs to be improved.The average days it takes to deliver products to customers are more than 10 days for each region.

>There is no sellers located in AP, RR, SE states. These could be the reason long delivery times to these states. For these areas new seller can be found to create a more stable logistic performance.
The other option is not selling products to these areas but there is already a customer base for these regions, if Olist wants to expand the sales area, Olist should consider to build new relationship new sellers from these states.

>Specifically for the AP state, delivering products take more than 20 days (red bars), Olist should consider making aggrements additional warehouses or optimizing existing logistics routes.

>In the "Mini Analysis; One Time Buyers vs Repeating Customers" section, I found out that 96.9% of the customers are one-time-buyers.These delivery times probably the most impactful reasons for this situation. Long delivery times make customers upset and prevent them to shopping from Olist consistently.

"""

#Visualize the delivery times by seller (Top 10 slowest sellers)
top_slow_sellers = avg_delivery_by_seller.sort_values(by='Avg_Delivery_Time', ascending=False).head(10)
top_slow_sellers= top_slow_sellers.merge(df_sellers[["seller_id","seller_state"]],right_on="seller_id", left_on="Seller_ID",how="inner")[["Seller_ID","Avg_Delivery_Time","seller_state"]]

plt.figure(figsize=(12, 6))
ax=sns.barplot(x='Seller_ID', y='Avg_Delivery_Time', data=top_slow_sellers)
#add annotation on bars


for i, row in top_slow_sellers.iterrows():
  annotation_text = f"{row['seller_state']}: {row['Avg_Delivery_Time']:.2f}"
  plt.annotate(annotation_text, (row['Seller_ID'], row['Avg_Delivery_Time']), xytext=(5, 5), textcoords='offset points')

plt.title('Top 10 Slowest Sellers by Delivery Time')
plt.xticks(rotation=90)
plt.ylabel('Average Delivery Time (days)')
plt.xlabel('Seller ID')
plt.show()

"""Unfortunately we dont have the name of sellers but seller_id. But this barplot indicates that sellers are really underperformed delivering products to customers.

Except from the sellers in RS, BA, the other states has already higlighted in the previous sections to be focused on. For the SP states (with the worst performance and the highest number of outliers) these sellers that appears in the bar chart can be prioritized.

## **Question 3: Product Performance Analysis based on States**

**Question**: Which product categories are popular in different states? Are there any specific categories that are particularly common or underperforming in certain locations?
"""

#Create dataframe to analyze product performance
#Get product category name from product table
df_product_perf=df_final_orders.merge(df_products[["product_id","product_category_name"]],right_on="product_id", left_on="product_id",how="inner")
#getting state information from customer table to explore which states commonly purchase which products
df_product_perf=df_product_perf.merge(df_customers[["customer_id","customer_state"]],right_on="customer_id", left_on="customer_id",how="inner")
#Drop unneccessary columns
df_product_perf = df_product_perf.loc[:, df_product_perf.columns.isin(["product_category_name","customer_state","order_id","Total_Order_Value","Total_Item"])]

df_product_perf.head(2)

"""> I applied **80-20 Pareto Principle** to define best performed product categories and top performing states for each product categories.

"""

#Calculate total pieces sold per product category
category_sales = df_product_perf.groupby('product_category_name')['Total_Item'].sum().reset_index()

#Sort product categories based on their quantity
category_sales = category_sales.sort_values('Total_Item', ascending=False)

#Calculate the cumulative percentage of sales
category_sales['cumulative_percentage'] = category_sales['Total_Item'].cumsum() / category_sales['Total_Item'].sum() * 100

#Apply the 80-20 rule
#Filter product categories that contribute to 80% of total sales
top_categories_80_20 = category_sales[category_sales['cumulative_percentage'] <= 80]['product_category_name'].tolist()

#Filter the dataset for these top product categories
top_category_data = df_product_perf[df_product_perf['product_category_name'].isin(top_categories_80_20)]

#Identify best performing states for each product categories
#Calculate total quantity sold per state within each product category
category_region_sales = top_category_data.groupby(['product_category_name', 'customer_state'])['Total_Item'].sum().reset_index()

#Sort by quantity sold within each category
category_region_sales = category_region_sales.sort_values(['product_category_name', 'Total_Item'], ascending=[True, False])

#For each product category, calculate cumulative percentage for states
category_region_sales['cumulative_percentage'] = category_region_sales.groupby('product_category_name')['Total_Item'].cumsum() / category_region_sales.groupby('product_category_name')['Total_Item'].transform('sum') * 100

#Apply 80-20 rule to states within each category
top_category_region_sales = category_region_sales[category_region_sales['cumulative_percentage'] <= 80]

top_category_region_sales.sort_values("Total_Item")

#Visualize data with bar chart
#Create a horizontal barplot of the best-performing product categories and states
plt.figure(figsize=(18, 12))


# Horizontal bar plot
barplot = sns.barplot(x='Total_Item', y='product_category_name', hue='customer_state', data=top_category_region_sales.sort_values("Total_Item", ascending=False), dodge=True)

#the title and labels
plt.title('Top-Selling Product Categories and Their Top Performing States by (80-20 Rule)', fontsize=16)
plt.xlabel('Total Pieces Sold', fontsize=12)
plt.ylabel('Product Category', fontsize=12)


plt.legend(title='Customer States', bbox_to_anchor=(1.05, 1), loc='upper left')

#annotations
for p in barplot.patches:
    width = p.get_width()
    plt.text(width + 1,  # Adjust the position of the text
             p.get_y() + p.get_height() / 2,
             f'{int(width):,}',  # Format the annotation text
             va='center', fontsize=10, color='black')


plt.tight_layout()
plt.show()

#For each top-selling product category, list its top-performing regions
#the list version of the bar chart
for category in top_categories_80_20:
    regions = top_category_region_sales[top_category_region_sales['product_category_name'] == category]
    print(f"Product Category: {category}")
    print("Top Regions:")
    print(regions[['customer_state', 'Total_Item']].to_string(index=False))
    print("\n")

"""**Observations;**

SP state dominates across all categories, we can say SP is the highest-performing state.Especially categories like cama_mesa_banho, beleza_saude and esporte_lazer perform well in SP, suggesting that SP is a key market for almost every category.

RJ, MG, RS are consistently best performing states for multiple product categories but not that as much as SP.

PR and BA are seen in some categories such as beleza_saude, esporte_lazer(PR), etc. These regions has a potential and may be targeted for growth.

For these best performing states and products Olist should monitor inventory availability closely to avoid stockouts and missed sales opportunities.

## **Question 4: Cross Selling and Up Selling Product Combinations**

**Question**: What are the most common product combinations ordered together? Determine cross-selling or up-selling products.
"""

#Create dataframe shows product id, category name, order_id, quantity and revenue
df_product_comb=df_final_orders.merge(df_products[["product_id","product_category_name"]],on="product_id",how="inner")[["order_id","product_id","product_category_name","Total_Item","Total_Order_Value","Unit_Price"]]
#drop product categories equals to "Other". In the data cleaning process, I filled null categories with others. I will not include this data into analysis
df_product_comb = df_product_comb[df_product_comb["product_category_name"] != "Others"]
df=df_product_comb

#Calculate the percentage of orders include more than one different product
multi_product_orders = df.groupby('order_id')['product_id'].nunique().reset_index()
multi_product_orders = multi_product_orders[multi_product_orders['product_id'] > 1]
print("The percentage of the orders that have more than one product to all orders: % {}".format((multi_product_orders["order_id"].nunique() / df["order_id"].nunique()) * 100))

"""The percentage of the orders that have more than one product to all orders shows that only 3%. The majority of customers purchase only a single type of product in their order. This indicates a significant opportunity to increase sales through upselling and cross-selling strategies by encouraging customers to add additional, different products to their orders.

### **Defining Upselling Product Categories**

> Upselling products refer to convince customers to buy more expensive products from the store.

> Orders that contain more than one product are included for this analysis.

> I calculated the contribution rate of each product to total order value.
I set treshold as 50% percentage to define upselling product categories.If product category contributes at least 50% percentage to the total order, this product category can be tagged as upselling product category.
"""

#merge filtered dataset with the original dataframe to include only multi-product orders
df_filtered = df.merge(multi_product_orders[['order_id']], on='order_id', how='inner')

#Calculate total quantity for each order
total_items_per_order = df_filtered.groupby('order_id')['Total_Item'].sum().reset_index()
total_items_per_order.rename(columns={'Total_Item': 'Total_Items'}, inplace=True)

#Calculate total order value for each order
total_order_value = df_filtered.groupby('order_id')['Total_Order_Value'].sum().reset_index()

#merge total order value and total items to the filtered dataframe
df_filtered = df_filtered.merge(total_order_value, on='order_id', suffixes=('', '_Total'))
df_filtered = df_filtered.merge(total_items_per_order, on='order_id')

#calculate the contribution of each product category to the total order value
df_filtered['Category_Contribution'] = (df_filtered['Total_Item'] * df_filtered['Total_Order_Value']) / df_filtered['Total_Items']

#set threshold as 50% of the total order value
threshold_percentage = 0.5

#calculate the minimum contribution required for upselling
df_filtered['Min_Contribution'] = df_filtered['Total_Order_Value_Total'] * threshold_percentage

#filter the categories that meet the upselling criteria
upselling_categories = df_filtered[df_filtered['Category_Contribution'] >= df_filtered['Min_Contribution']]

#Get unique product categories that meet the upselling criteria
unique_upselling_categories = upselling_categories['product_category_name'].unique()

print("Upselling Product Categories based on the 50% threshold for multi-product orders:\n")
print(unique_upselling_categories)
print("\nNumber of Upselling Product Categories:", len(unique_upselling_categories))

""" Out of 73 categories, 15 categories were identified as key upselling opportunities. These categories significantly contribute to at least 50% of the total order value when included in multi-product orders."""

#How many times this upselling product categories appeared in orders?
sns.set(style="whitegrid")

category_counts = upselling_categories.groupby("product_category_name")["order_id"].count().reset_index(name='count').sort_values(by='count', ascending =False)
plt.figure(figsize=(12, 8))
sns.barplot(x='count', y='product_category_name', data=category_counts, palette='viridis')

#annotations
for i in range(len(category_counts)):
    count = category_counts.iloc[i, 1]
    plt.text(count, i, count, va='center')


#titles and labels
plt.title('Upselling Product Categories Distribution', fontsize=16)
plt.xlabel('Count of Distinct Orders', fontsize=14)
plt.ylabel('Product Category', fontsize=14)

plt.show()

"""**Observations**


> The bar plot represents the upselling product categories based on their frequency in multi-product orders. Targeting these key categories (e.g., cama_mesa_banho, beleza_saude, and esporte_lazer) to promote additional products in customer orders, helping to increase the chance of a multi-product purchase.

### **Defining Cross Selling Products**

> In the current scenario, only 3% of orders have more than one different product. I think defining and focusing on cross-selling products is crucial to increasing order revenue value and customer satisfaction by recommending related or complementary products to convince customers to purchase more products.

> In this analysis, Products ordered more than 5 times are included and each pair should appear at least 5 times to be considered as cross selling product categories.

>The data only have product id, so instead of sharing theirs names, id information will be displayed in the figures.
"""

#products should be ordered at least 5 times
min_order_count = 5
product_counts = df['product_id'].value_counts()
frequent_products = product_counts[product_counts >= min_order_count].index

#Filter the dataset for frequent products only
df_filtered = df[df['product_id'].isin(frequent_products)]

#Calculating product combinations bought together
from itertools import combinations
from collections import Counter

#Create a list of product sets (products in the same order)
product_sets = df_filtered.groupby('order_id')['product_id'].apply(set)

#Generate all possible product pairs (combinations of two products per order)
product_pairs = product_sets.apply(lambda x: list(combinations(x, 2)))

#Flatten the list of product pairs
flat_product_pairs = [pair for sublist in product_pairs for pair in sublist]

#Count how often each product pair appears together
pair_counts = Counter(flat_product_pairs)

#Convert to DataFrame for analysis
pair_df = pd.DataFrame(pair_counts.items(), columns=['product_pair', 'count']).sort_values(by='count', ascending=False)

# Filter pairs that appear together more than 5 times
threshold = 5
cross_selling_opportunities = pair_df[pair_df['count'] >= threshold]

print("Top Cross-Selling Product Pairs:")
print(cross_selling_opportunities.head(10))

#I want to list the each product along with their category name
pair_df[['product1', 'product2']] = pd.DataFrame(pair_df['product_pair'].tolist(), index=pair_df.index)

# Merge with the product mapping to get category names
pair_df = pair_df.merge(df_products, left_on='product1', right_on='product_id', how='left').rename(columns={'product_category_name': 'category1'})
pair_df = pair_df.merge(df_products, left_on='product2', right_on='product_id', how='left').rename(columns={'product_category_name': 'category2'})

#Drop unnecessary columns like the duplicate product_id
pair_df = pair_df[['product1', 'category1', 'product2', 'category2', 'count']]

print(pair_df.head())

#visualize the top 10 cross-selling opportunities with category names
top_cross_sell = pair_df.head(10)

#format product and category together for better visualization
top_cross_sell['product_pair'] = top_cross_sell.apply(lambda row: f"{row['category1']} ({row['product1']}) & {row['category2']} ({row['product2']})", axis=1)

plt.figure(figsize=(10,6))
plt.barh(top_cross_sell['product_pair'], top_cross_sell['count'], color='green')
plt.gca().invert_yaxis()
ax = plt.gca()

#Add annotation
for i in ax.patches:
  plt.text(i.get_x() + i.get_width(), i.get_y() + 0.2,
           str(round((i.get_width()), 2)),
           fontsize = 10, fontweight ='bold',
           color ='black')

plt.xlabel('Number of Co-Occurrences')
plt.title('Top 10 Cross-Selling Product Pairs (with Category Names)')
plt.show()

"""**Observation**

Many of the product pairs are from the same product categories, such as Informatica_Acessorios and Ferramentas_Jardim.

Olist can focus on promoting products that frequently sold together, such as Informatica_Acessorios category. For example, suggesting related items to customer during purchase from this category can promote the customer to buy additional products.

Developing promotional bundles or discounts for cross selling products is really crucial in the name of boosting sales by appealing customers.

The product ids listed together in the bar chart is a great options to create bundle. For example, Olist can create Informatica_Acessorios bundles by using these two product id; "36f60d45225e60c7da4558b070ce4b60", e53e557d5a159f5aa2c5e995dfdf244b

## **Question 5: Impact of Shipment Costs**

**Question**: What is the impact of shipment costs(Freight) on revenue?

So far, in the delivery performance section, It is discovered Olist experiences long delivery duration, particularly sellers in the SP state. Moreover, outlier detection indicated certain seller consistenly underperforming in terms of shipment efficiency. Considering that, The only cost the dataset has is a freight (shipment) cost. Analyzing impact of this shipment cost on overall revenue may highlights the need for new effective logistic strategies.

> In the delivery performance section,  it has been observed that there is a moderate corelation between shipment duration and distance_km (from seller to customer). The corelation betweeen Freight cost, duration, and product size information such as kg, length, etc. will be calculated again.

>Freigh Percentage = (Unit Freight Value / Total Order Value) * 100 will be used as a main KPI to measure effect of shipment costs.
"""

#Create a dataframe to use in the analysis.
#Same steps in the delivery section are followed
#Get customer location information from customer dataframe
freight_df= df_final_orders[["order_id",
                             "seller_id",
                             "customer_id",
                             "product_id",
                             "order_purchase_timestamp",
                             "order_delivered_customer_date",
                             "Total_Order_Value",
                             "Total_Item",
                             "Freight_Value"]].merge(df_customers[["customer_id","customer_state","customer_city","lat","long"]],on="customer_id",how="inner")
#Get seller location information from seller dataframe
freight_df=freight_df.merge(df_sellers[["seller_city","seller_state","lat","long","seller_id"]],on="seller_id",how="inner")
#get the product information from product dataframe
freight_df=freight_df.merge(df_products[["product_id","product_category_name","product_weight_g","product_length_cm","product_height_cm","product_width_cm"]],on="product_id",how="inner")
#adjust date columns
freight_df["order_purchase_timestamp"]=pd.to_datetime(freight_df["order_purchase_timestamp"])
freight_df["order_delivered_customer_date"]=pd.to_datetime(freight_df["order_delivered_customer_date"])
#rename columns
freight_df.rename(columns=({"order_purchase_timestamp":"order_date",
                            "order_delivered_customer_date":"delivered_date",
                            "lat_x":"lat_customer",
                            "long_x":"long_customer",
                            "lat_y":"lat_seller",
                            "long_y":"long_seller"}),inplace=True)

freight_df['duration'] = (freight_df['delivered_date'] - freight_df['order_date']).dt.days

#use haversine again to calculate distance between customer and seller
freight_df['distance_km'] = freight_df.apply(lambda row: haversine(row['lat_seller'], row['long_seller'], row['lat_customer'], row['long_customer']), axis=1)

#Add KPI
freight_df['freight_percentage'] = (freight_df['Freight_Value'] / freight_df['Total_Order_Value']) * 100

#be able to see each column
pd.set_option('display.max_columns', None)
print("Head 3 rows of freight_df:")
freight_df.head(3)
#pd.reset_option('display.max_columns')

freight_df.describe().T

"""**Observation**

1. Total Order Value: The range is significant, with a minimum value of 7.28 and a maximum of 13,468.01. The majority of purchases are moderate value. (%75 percentile is 167.8). Even though the number is less, there are some high-value orders.

2. Freight_Value & Freight_Percentage: The mean of Freight Value is 20 but there are some outliers with 409.68. It was revealed and analyzed that there are outliers in the dataset in case of shipment process. We can notice this situation by checking the "duration" columns again.

 For many orders, the freight cost could be a significant part of the total order value (the mean is 20.16 %), This ratio could potentially discouraging and negatively effect the profitability of sales.

 We can also say that there are free shipping policy for some of the orders


3. Product Weight and Dimensions: The average value of product weight is roughly 2 kg,  Product Weight shows wide range to 40 kg. We can say that the catalog of products consist of small or heavy ones.

### **Analyzing Free Shipping**
"""

#tag orders that offer free shipping
freight_df['free_shipping'] = freight_df['Freight_Value'].apply(lambda x: 'free shipping' if x == 0 else 'other')

#The percentage of free shipment to all shipments;
print("The percentage of orders offer free shipment to all orders")
print("{:.2%}".format(freight_df[freight_df["free_shipping"]=="free shipping"]["order_id"].nunique()/freight_df["order_id"].nunique()))

#Productweights for free shipment orders
freight_df[freight_df['Freight_Value'] == 0]['product_weight_g'].agg(['min', 'max', 'mean', 'std'])

#check distance for free shipments
freight_df[freight_df['Freight_Value'] == 0]['distance_km'].agg(['min', 'max', 'mean', 'std'])

"""> Only 0.35% of orders offer free shipment, which is a very small.

> The mean product weight for free shipment orders is relatively low at around 1.5kg, though there are cases with significantly heavier items.

> On average, free shipping orders travel around 671 km, with some deliveries covering significant distances such as 2387 km.

> Free shipment may be a effective tool to boost customer retention or gain new customers and increase sales. The key point is to be carefully managed to avoid profitability damage.Based on the current data, offering free shipment on lighter products and for shorter distances could have a positive impact on customer attraction and sales increase

### **Investigation of Outliers**

I will use IQR method again to define outliers in the Freight Value.
"""

#For freight cost i will only focus on upper bound to identify outliers that represent unusually high freight costs
Q1 = freight_df['Freight_Value'].quantile(0.25)
Q3 = freight_df['Freight_Value'].quantile(0.75)
IQR = Q3 - Q1
upper_bound = Q3 + 1.5 * IQR
print("Upper bound to define outlier is: ",upper_bound)
freight_df['freight_outlier'] = freight_df['Freight_Value'].apply(lambda x: 'Outlier' if x > upper_bound else 'Other')

"""High freight cost outliers can indicate:

1. Long-distance shipments

2. Potential data entry errors in freight costs.

3. Products that are bulky or heavy requiring additional logistics costs.
"""

#calculate the total weight of the order. Because some orders inludes more than one product
freight_df["Total_Weight"]=freight_df["product_weight_g"]*freight_df["Total_Item"]

"""### **Comparison Outliers vs Non Outliers**"""

#Group by outliers flag to get summary of outliers and non-outliers
category_summary = freight_df.groupby([ 'freight_outlier']) \
    .agg({
        'Freight_Value': ['mean', 'sum', 'min', 'max'],
        'Total_Order_Value': ['mean', 'sum'],
        'Total_Weight': ['mean', 'std'],
        'distance_km': ['mean', 'std'],

    }) \
    .reset_index()

#Flatten the multi-level columns
category_summary.columns = ['Outlier_Flag', 'Mean_Freight_Cost','Total_Freight','Min_Freight_Cost','Max_Freight_Cost',
                             'Mean_Order_Value', 'Total_Order_Value',
                            'Mean_Weight', 'Std_Weight',
                            'Mean_distance', 'Std_distance']

#Calculate the percentage of freight
category_summary['Freight_Percentage'] = (category_summary['Total_Freight'] / category_summary['Total_Order_Value']) * 100

category_summary

#visualize the category_summary
#compare outliers vs. nonoutliers
#Create subplots
fig, ax = plt.subplots(2, 2, figsize=(12, 10))

colors = {'Other': 'green', 'Outlier': 'maroon'}

#add annotations
def add_annotations(ax):
    for p in ax.patches:
        height = p.get_height()
        ax.annotate(f'{height:.2f}',
                    (p.get_x() + p.get_width() / 2., height),
                    ha='center', va='center',
                    xytext=(0, 5),
                    textcoords='offset points',
                    fontsize=10, color='black')

#Bar plot for Freight Cost (Outlier vs Non-outlier)
sns.barplot(x='Outlier_Flag', y='Mean_Freight_Cost', data=category_summary, ax=ax[0, 0], palette=colors)
ax[0, 0].set_title('Mean Freight Cost: Outlier vs Non-Outlier')
ax[0, 0].set_ylabel('Mean Freight Cost')
add_annotations(ax[0][0])

#Bar plot for Mean Order Value (Outlier vs Non-outlier)
sns.barplot(x='Outlier_Flag', y='Mean_Order_Value', data=category_summary, ax=ax[0, 1], palette=colors)
ax[0, 1].set_title('Mean Order Value: Outlier vs Non-Outlier')
ax[0, 1].set_ylabel('Mean Order Value')
add_annotations(ax[0][1])

#Bar plot for Mean Weight (Outlier vs Non-outlier)
sns.barplot(x='Outlier_Flag', y='Mean_Weight', data=category_summary, ax=ax[1, 0], palette=colors)
ax[1, 0].set_title('Mean Weight: Outlier vs Non-Outlier')
ax[1, 0].set_ylabel('Mean Weight (g)')
add_annotations(ax[1][0])

#Bar plot for Mean Distance (Outlier vs Non-outlier)
sns.barplot(x='Outlier_Flag', y='Mean_distance', data=category_summary, ax=ax[1, 1],  palette=colors)
ax[1, 1].set_title('Mean Distance: Outlier vs Non-Outlier')
ax[1, 1].set_ylabel('Mean Distance (km)')
add_annotations(ax[1][1])

plt.tight_layout()
plt.show()

"""**Observation**

> Outliers tend to have significantly higher freight costs compared to non-outliers.

> Outliers have much higher average order values than non-outliers, suggesting a possible relationship between higher freight costs and high-value orders.

> The average weight of products in outlier orders is significantly higher, showing that carrying heavy products lead to the higher shipping costs.

> Outliers show longer delivery distances, indicating that shipping longer distances increases freight costs.

**Impact of Shipment Costs (Freight) on Total Revenue:**

By Freight_Percentage in the category_summary dataframe;

> For non-outliers, the freight cost represents about 12.55% of the order value.

> For outliers, the freight cost percentage is 15.21% to the order value.

>This suggests that higher freight costs, especially for outliers, reduce profit because of the increased share of shipment costs compared to order value (freight percentage).

>Strategies to reduce freight costs for outliers could improve overall profitability, especially for high-value and heavy products(average 8 kg). Negotiating with sellers and asking discounts on shipping prices for specially large orders in terms of value for money (more than 130)  will encourage customers to order more and becoming a loyal customer.

>By making deals with new sellers from different states, Olist can reduce the distance between the customer and the seller and naturally decrease freight costs.

# **Final Discussion**

>In the EDA section comprehensive analysis were provided such as variety of product categories, sales trend and logistic performance.

>Outliers in the delivery duration, peak periods of sales, sales growth based on timeline were identified.

>By analyzing delivery times, sales data, product categories I highligted spesific areas to improvement such as spesific regions with slow deliviries, high performing categories and regions to build a clear growt strategy.

>There were missing values or unmatching values between tables. For example unmatching orders limited a complete understanding of the customer base (2.68%)
There were missign order dates, this also restrict the analysis.

>I used various methods to detect outliers such as IQR, MAD, etc. Especially for delivery duratio, these outliers may indicate logistic problems.

>Also the sales data was limited and covers only from 2017 to 2018, Sales data showed positive growth, I believe more data provide much more reliable insights.

>The significant growth in November, I believe it is due to Black Friday, shows the importance of seasonal promotions. As I mentioned before, Olist needs to build new sales strategy to maintain sales after Black Friday to avoid the drop in sales afterward Black Friday.

>There are crucial problems with delivery times, To me, it is quiete long for e-commerce company.
I listed spesific regions to handle the logistic problems along with seller_id.

>96.9% of customers are one-time buyers, improvments in delivery speed could boost repeat sales.

>Additionally, to increase the customer loyalty, olist may offer promotions or use recommendation engines. Promoting bundles, cross-selling techniques can be developed based on the product pair list that I created in Question 4 chapter. Also the free shipping ratio is really low, offering free shipping options may catch the customer attention.

>I listed state pairs based on their performance, some of them showed inconsistency. Especially from SP to RJ. Focusing and optimizing these routes by negotiating better deals with sellers could enhance customer satisfaction and reduce the logistic based costs.

By following these recommendations I listed, Olist can enhance its overall  efficiency and continue to grow, increase profitability.
"""

# Commented out IPython magic to ensure Python compatibility.
# %%shell
# jupyter nbconvert --to html /content/GH1030814_FinalAssesment.ipynb
# 
# 
#